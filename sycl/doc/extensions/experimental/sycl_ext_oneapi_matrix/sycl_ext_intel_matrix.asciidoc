= sycl_ext_intel_matrix

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

Copyright (c) 2022-2023 Intel Corporation.  All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues

== Dependencies

This extension is written against the SYCL 2020 revision 6 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_matrix/sycl_ext_oneapi_matrix.asciidoc[
  sycl_ext_oneapi_matrix]

== Status
This is an experimental extension specification, intended to provide early
access to features and gather community feedback.  Interfaces defined in this
specification are implemented in {dpcpp}, but they are not finalized and may
change incompatibly in future versions of {dpcpp} without prior notice.
*Shipping software products should not rely on APIs defined in this
specification.*

== Backend support status
This document describes the extra features and details for the
implementation of `joint_matrix` extension on Intel AMX and Intel
XMX.

The APIs in this extension may be used only on a device that has
`aspect::ext_intel_matrix`. The application must check that the device
has this aspect before submitting a kernel using any of the APIs in
this extension. If the application fails to do this, the
implementation throws a synchronous exception with the
`errc::kernel_not_supported` error code when the kernel is submitted to
the queue.

== Overview
This extension provides additional APIs related to the `joint_matrix`
type that can be used only on Intel devices that have Intel AMX or
Intel XMX technology. These Intel devices also support all of the
generic matrix APIs specified in `sycl_ext_oneapi_matrix`, but
applications can make use of the extended Intel specific APIs in this
extension to gain additional performance and capabilities.

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification. An implementation supporting this extension must
predefine the macro `SYCL_EXT_INTEL_MATRIX` to one of the values
defined in the table below.Applications can test for the existence of
this macro to determine if the implementation supports this feature,
or applications can test the macro's value to determine which of the
extension's APIs the implementation supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== New Aspect for Intel-Specific Matrix APIs
This extension adds a new device aspect:

namespace sycl {

enum class aspect : /*unspecified*/ {
  ext_intel_matrix
};

} // namespace sycl

The `ext_intel_matrix` aspect indicates that the device is capable of
using the extended joint matrix APIs that are defined in the sections
that follow.

=== New Layout Type
This extension adds a new layout type named `ext_intel_packed` which
an application can use to indicate that the matrix data is loaded or
stored in VNNI "packed" format.

```c++
namespace sycl::ext::oneapi::experimental::matrix::layout {

enum class layout {
  ext_intel_packed
};

} // namespace sycl::ext::oneapi::experimental::matrix
```


Consequently, the layout argument `layout` in `joint_matrix_load` can
take `ext_intel_packed` as argument to specify that the data has
already been transformed into VNNI format. in this case, `stride`
argument of `joint_matrix_load` describes the number of elements
between consecutive rows for packed layouts.

In order to get maximum performance on Intel AMX and Intel XMX,
prepacking data in the memory is necessary. If users did not specify
the packed layouts, transforms done by the implementation may be slow
due to extra scatter/gather operations. Hence, we expose the
`ext_intel_packed` layout to the user to specify that A or B have
already been VNNIed. The packed or VNNI layout is introduced in the
`VNNI layout` section below.

=== Additional Store Operations
Besides store of matrix `accumulator`, the Intel implementation allows
store on matrix `a` and `b` as well.

```c++
namespace sycl::ext::intel::experimental::matrix {

template <typename Group, typename T, size_t Rows, size_t Cols,
          layout Layout, access::address_space Space,
          access::decorated IsDecorated>
void joint_matrix_store(Group g,
    joint_matrix<Group, T, use::a, Rows, Cols, Layout> &res,
    multi_ptr<T, Space, IsDecorated> src, size_t stride);

template <typename Group, typename T, size_t Rows, size_t Cols,
          layout Layout, access::address_space Space,
          access::decorated IsDecorated>
void joint_matrix_store(Group g,
    joint_matrix<Group, T, use::b, Rows, Cols, Layout> &res,
    multi_ptr<T, Space, IsDecorated> src, size_t stride);

} // namespace sycl::ext::intel::experimental::matrix
```

=== Per-element Operations with Coordinates
The function `joint_matrix_apply` in `sycl_ext_oneapi_matrix` provides
a way for the application to apply the same operation on every element
of the matrix. However, some algorithms require the application to
know the coordinates of each element as it operates on
them. In this case, the operation depends on the element index of the
matrix or the operation takes multiple elements as operands (such as a
sum of all elements in a row for example). Quantization that is needed
for conversion between low precision types like `int8_t` and `fp32`
uses such piece-wise operations.

==== Explicit conversion with mapping from SIMD to SPMD
The data elements in a `joint_matrix` are distributed or shared across
the work-items in the Group in an implementation-defined way. There is
no fixed allocation of matrix elements owned by a `joint_matrix`
instance to the WIs comprising the group used to instantiate it. For
instance, the matrix is a shared entity among the work items in the
case of the AMX backend because the AMX tile that holds the matrix
data is a 2d register that is shared among the work items. Therefore
the partitioning among the WIs is implementation defined. However, it
is necessary to allocate WIs to specific elements of the matrix in
order to perform element-wise operations. In order to be able to
perform element-wise operations in a general and efficient way, we
provide a conversion function from the `joint_matrix` domain that is
owned by a group of work items to the portion that is owned by each
work item. This enables the WI to perform piece-wise operations on the
matrix within the SYCL SPMD programming model.

We introduce a new function `get_wi_data` that provides a view of the
portion of the matrix that is owned by the current WI. The indexing
provided inside the `wi_data` class accesses only the portion of the
current WI and returns  `wi_element`. This latter holds a reference to
the original joint_matrix that `wi_data` was constructed from. This
means that modifying `wi_data` also modifies the corresponding joint
matrix elements. Users can use the `=` operator to update the element
of the `joint_matrix` represented by the `wi_element` after the
element-wise operation.

Using `get_wi_data`, it is not possible to know which portions of data
are owned by each thread in the group as this is implementation
defined and changes from one backend to the other. For general
piece-wise operations such as summing the rows of a matrix, the WI
data to joint matrix mapping coordinates information must be known in
order to reason about the matrix view and extract the relevant
piece. However, for element-wise operations where the same operation
is performed on all the elements of the matrix, having all the WIs in
the group apply the operation inside a loop iterating over the
`length` of `wi_data` guarantees the whole matrix element-wise operation.

Note that `get_wi_data` cannot return a fixed size array length
because the length of the WI portion is a runtime variable for the
following reasons:

1- The main compilation mode of SYCL is JIT compilation and
partitioning among WIs is implementation defined.

2- Sub group size is not generally fixed.

The code listing below shows a synopsis of these new APIs.

```c++
namespace sycl::ext::intel::experimental::matrix {

wi_data<group, T, Use, Rows, Cols, Layout> get_wi_data(Group g,
 joint_matrix<Group, T, Use, Rows, Cols, Layout> Mat);

template <typename T, size_t Rows, size_t Cols, use Use, layout
Layout, typename Group>
class wi_data {
  size_t length();
  wi_element<T, Rows, Cols, Use, Layout, Group> operator[](size_t i);
};
template <typename T, size_t Rows, size_t Cols,
          use Use, layout Layout,
          typename Group = sycl::sub_group>
class wi_element {
  operator T();
  wi_element &operator=(const T &rhs);
  wi_element &operator+=(const T &rhs);
  wi_element &operator-=(const T &rhs);
  wi_element &operator*=(const T &rhs);
  wi_element &operator/=(const T &rhs);

  std::tuple<size_t, size_t> get_coord();
};

} // namespace sycl::ext::intel::experimental::matrix
```

In the following example `wi_data_c` is a reference to the WI owned
portion of the joint matrix `matC`. As such `wi_data_c[i] OP rhs`
updates the corresponding matrix element in the joint_matrix `matC`.
Vectorization along the sub group dimension will get enabled
automatically to vectorize the contiguous portion of the matrix.


```c++
auto wi_data_c = get_wi_data(sg, matC);
for (int i = 0; i < wi_data_c.length(); i++)
  wi_data_c[i] *= alpha;    // Note that the indexing here "i"
  //is in the vector owned by a WI, not in the matrix C
```

==== Work-item data to joint matrix mapping coordinates
The `wi_data` and `wi_element` classes provide access to the matrix
elements that are local to the calling work-item. However, the
distribution of matrix elements to each work-item is
implementation-defined, so application code cannot assume any fixed
distribution. Instead, application code can use the `get_coord` method
to query the matrix coordinates of an individual `wi_element`.

`get_coord` returns [row,col] coordinates of the current object
`wi_element` of the joint matrix.  The code above results into the following:

```c++
auto data = get_wi_data(sg, tA);
// each WI calculates local sum of rows
for (int i = 0; i < data.length(); ++i) {
  auto [row, col] = data[i].get_coord();
  sum_local_rows[row] += data[i];
}
```

==== Extending `joint_matrix_apply` with the mapping coordinates
This extension adds a new form of the `joint_matrix_apply` function in
the `sycl::ext::intel::matrix` namespace that allows the application
to perform an operation on each element of the matrix. This function
is similar to the form in `sycl_ext_oneapi_joint_matrix`, but it also
provides the matrix coordinates of each element to the callback
function:
```c++
namespace sycl::ext::intel::experimental::matrix {

template<typename Group, typename T, use Use, size_t Rows, size_t
         Cols, layout Layout, typename F>
void joint_matrix_apply(Group g, joint_matrix<Group, T, Use, Rows,
                        Cols, Layout>& C, F&& func);

} // namespace sycl::ext::intel::experimental::matrix
```
The `func` callback is invoked with three parameters `(T& element,
size_t row, size_t col)`, where `row` and `col` tell the coordinates
of element in the joint matrix. To illustrate, the following example
shows how you can use this API to sum the rows of a matrix:

```c++
joint_matrix_apply(sg, A, [=](T &val, size_t row, size_t  col) {
   sum_local_rows[row] += val;
});
```
=== New Device Information Descriptor
Besides the query we provide in
link:../experimental/sycl_ext_oneapi_matrix/sycl_ext_oneapi_matrix.asciidoc[sycl_ext_oneapi_matrix],
some device descriptors are Intel hardware specific. These are
provided as part of `ext::intel::experimental::info::device::matrix`
namespace:

[frame="none",options="header"]
|======================
| Device descriptors | Return type| Description
|`ext::intel::experimental::info::device::matrix::numtiles`| `int`
|If the matrix hardware in the device has separate storage (register
files or tiles) from the rest of the processing units (e.g. Intel
AMX), returns the number of tiles. For other devices, returns 0.
|======================

=== Packed Layout Format
The `ext_intel_packed` layout (aka VNNI) is a special layout for
matrix data that allows Intel AMX and Intel XMX devices to load
matrices more efficiently (packing in 32 bits). This layout applies
only to the A and B matrices, and may not be used with the accumulator
matrix. The layout is different depending on whether the matrix
element type is 8 bits or 16 bits, which are the only two element
sizes supported for the A and B matrices on Intel AMX and Intel XMX
devices.

For an 8-bit element, the first four elements of column 0 are stored
contiguously in memory, followed by the first four elements of column
1, etc. This continues until the end of the row. After all the
elements for rows 0 - 3 have been stored this way, the process
repeats, starting with the next four elements of column 0. The diagram
below illustrates this layout for a 8 x 4 matrix.

==== Example 1: 8-bit elements

      // Example of a 8 row x 4 column matrix using a 8-bit data
      // element, in row-major layout, rows are shown horizontally.
      // Element a1 is contiguous in memory with element b1, etc.
      // ---------------------------------
      // a1, b1, c1, d1
      // a2, b2, c2, d2
      // a3, b3, c3, d3
      // a4, b4, c4, d4
      // a5, b5, c5, d5
      // a6, b6, c6, d6
      // a7, b7, c7, d7
      // a8, b8, c8, d8
      // ---------------------------------
      // The same matrix reformatted in packed layout.
      // Here, packing of 4 elements is needed to form 32 bits.
      // Elements a1, a2, a3, a4 are contiguous in memory, etc.
      // ---------------------------------
      // a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4
      // a5, a6, a7, a8, b5, b6, b7, b8, c5, c6, c7, c8, d5, d6, d7, d8

For a 16-bit element, the first two elements of column 0 are stored
contiguously in memory, followed by the first two elements of column
1, etc. This continues until the end of the row. After all the
elements for rows 0 - 1 have been stored this way, the process
repeats, starting with the next two elements of column 0. The diagram
below illustrates this layout for a 4 x 4 matrix.

==== Example 2: 16-bit elements
      // Example of a 4 row x 4 column matrix using a 16-bit data
      // element, in row-major layout.
      // Element a1 is contiguous in memory with element b1, etc.
      // ---------------------------------
      // a1, b1, c1, d1
      // a2, b2, c2, d2
      // a3, b3, c3, d3
      // a4, b4, c4, d4
      // ---------------------------------
      // The same matrix reformatted in packed layout.
      // Here, packing of 2 elements is needed to form 32 bits.
      // Element a1 is contiguous in memory with element a2, etc.
      // ---------------------------------
      // a1, a2, b1, b2, c1, c2, d1, d2
      // a3, a4, b3, b4, c3, c4, d3, d4

=== Example using int8_t type
```c++
using namespace sycl::ext::oneapi::experimental::matrix;

queue q;
range<2> G = {M/tM, N};
range<2> L = {1, SG_SIZE};
auto bufA = sycl::buffer{memA, sycl::range{M*K}};
auto bufB = sycl::buffer{memB, sycl::range{K*N}};
auto bufC = sycl::buffer{memC, sycl::range{M*N}};
q.submit([&](sycl::handler& cgh) {
  auto accA = sycl::accessor{bufA, cgh, sycl::read_only};
  auto accB = sycl::accessor{bufB, cgh, sycl::read_only};
  auto accC = sycl::accessor{bufC, cgh, sycl::read_write};
  cgh.parallel_for(nd_range<2>(G, L), [=](nd_item<2> item)
  [[sycl::reqd_sub_group_size(SG_SIZE)]] {
    const auto global_idx = item.get_global_id(0);
    const auto global_idy = item.get_global_id(1);
    const auto sg_startx = global_idx - item.get_local_id(0);
    const auto sg_starty = global_idy - item.get_local_id(1);
    sub_group sg = item.get_sub_group();
    joint_matrix<sub_group, int8_t, use::a, tM, tK, layout::row_major> tA;
    joint_matrix<sub_group, int8_t, use::b, tK, tN,
                 layout::ext_intel_packed> tB; 
    joint_matrix<sub_group, int32_t, use::accumulator, tM, tN> tC;
    joint_matrix_fill(sg, tC, 0);
    for (int k = 0; k < K; k += tK) {
      joint_matrix_load(sg, tA, accA + sg_startx * tM * K + k, K);
      joint_matrix_load(sg, tB, accB + k * N*4 + sg_starty/SG_SIZE*tN*4, N*4);
      tC = joint_matrix_mad(sg, tA, tB, tC);
    }
    auto wi_data_c = ext::intel::experimental::matrix::get_wi_data(sg, tC);
    for (int i = 0; i < wi_data_c.length(); i++)
      wi_data_c[i] *= alpha;
    joint_matrix_store(sg, tC,
      accC + sg_startx * tM * N + sg_starty/SG_SIZE*tN, N, layout::row_major);
  });
});
q.wait();
```
== Revision History

[frame="none",options="header"]
|======================
|Rev |Date       |Author     |Changes
|1   |2022-11-07 |Dounia Khaldi |Add Intel-specific store API,
layout information, iterative-based element-wise operations, and
mapping
|======================
